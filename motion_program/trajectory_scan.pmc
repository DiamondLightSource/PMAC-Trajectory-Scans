#include "./trajectory_scan.h"

; *****************************************************************************************
; Set-Up
; *****************************************************************************************

Del Gat

; Set Initial Values
BufferLength = 1000
BufferAdr_A = $BufferAdr                        ; Set in header file (Default = 30000)
BufferAdr_B = BufferAdr_A + 10*BufferLength
BlankAddress = 0
Status = 0
Abort = 0
Error = 0

; Make sure all buffers are closed
Close

; *****************************************************************************************
; Program
; *****************************************************************************************

Open Prog 1
Clear

Abs
FRAX(X,Y,Z,U,V,W,A,B,C)

Status = 1                          ; Reset values to defaults
Abort = 0
Error = 0
Trigger = 0
CurrentIndex = 0
TotalPoints = 0
P4201 = 0
P4202 = 0

CurrentBufferAdr = BufferAdr_A      ; Set CurrentBuffer values to buffer A
CurrentBufferFill = BufferFill_A
CurrentBuffer = 0

PrevBufferFill = BufferLength       ; Set PrevBufferFill to pass outer while loop condition

GoSub1                              ; Check which axes are required
GoSub3                              ; Set addresses for required axes

While(Abort = 0 and Error = 0 and CurrentBufferFill > 0 and PrevBufferFill = BufferLength)

    P4201 = P4201 + 1

    ; Toggle buffer - Change address & specifier, set new buffer fill, reset previous buffer fill
    If(P4201>1) ; Don't run on first loop
        If(CurrentBuffer = 0)
            CurrentBufferAdr = BufferAdr_B
            CurrentBuffer = 1
            CurrentBufferFill = BufferFill_B
            BufferFill_A = 0
        Else
            CurrentBufferAdr = BufferAdr_A
            CurrentBuffer = 0
            CurrentBufferFill = BufferFill_A
            BufferFill_B = 0
        End If
    End If

    CurrentIndex = 0
    While(Abort = 0 and Error = 0 and CurrentIndex < CurrentBufferFill)

        P4202 = P4202 + 1

        Next_Time = Next_Time_N/4           ; Convert 1/4s of a ms into ms

        GoSub2                              ; Shift values through Next_* -> *_Coord -> Prev_*
        GoSub3                              ; Update Next_* addresses based on incremented `CurrentIndex`
        PVT (Time)                          ; Set move time
        GoSub4                              ; Calculate velocities
        GoSub8                              ; Move axes

        ; Run any required subroutine
        If(User > 0)
            GoSub(User)
        End If

        CurrentIndex = CurrentIndex + 1
        TotalPoints = TotalPoints + 1

        ; Check for following error and run-time error
        If(M141 = 1 or M241 = 1 or RTE = 1)
            Error = 3
            Status = 3
        End If

    End While

    GoSub2                                  ; Shift previous/current coordinates to N-1th/Nth points in buffer

    PrevBufferFill = CurrentBufferFill      ; Update previous buffer fill level - exit while loop if it wasn't full

End While

; Set finished Idle Status if no error occurred - also move to final point if scan wasn't aborted
If(Status = 1)
    If(Abort = 0)
        GoSub2                  ; Shift to final points in buffer
        PVT (Time)              ; Set move time
        GoSub7                  ; Prev->Current velocity calculation
        GoSub8                  ; Move axes
    End If
    Status = 2                  ; Set program finished (Idle status)
End If

CMD"A"                          ; Abort program so it doesn't run through Subroutines
While(1=1)                      ; Infinite While loop to make sure
End While

; Subroutine 1 ************************************************************************************
; Check that axes value is valid and assign required axes
; The *_Axis values point to the bits of AxesParser and therefore represent the required axes
; *************************************************************************************************
N1
    If(Axes > 511 or Axes < 1)
        Status = 3
        Error = 1
    Else
        AxesParser = Axes   ; Set bit parsed address to set required axes
    End If
Return

; Subroutine 2 ************************************************************************************
; Shift coordinate buffer through Next -> Coord -> Prev
; *************************************************************************************************

N2
    Time = Next_Time
    User = Next_User
    VelMode = NextVelMode

    Prev_X = X_Coord
    X_Coord = Next_X
    Prev_Y = Y_Coord
    Y_Coord = Next_Y
    Prev_Z = Z_Coord
    Z_Coord = Next_Z
    Prev_U = U_Coord
    U_Coord = Next_U
    Prev_V = V_Coord
    V_Coord = Next_V
    Prev_W = W_Coord
    W_Coord = Next_W
    Prev_A = A_Coord
    A_Coord = Next_A
    Prev_B = B_Coord
    B_Coord = Next_B
    Prev_C = C_Coord
    C_Coord = Next_C
Return

; Subroutine 3 ************************************************************************************
; Assign coordinate pointers based on CurrentBufferAdr, CurrentIndex and BufferLength
; If the axis is not activated, it won't be incremented and will remain pointing to the BlankAdr
; *************************************************************************************************

N3
    Time_Adr = CurrentBufferAdr + CurrentIndex
    User_Adr = CurrentBufferAdr + CurrentIndex
    VelMode_Adr = CurrentBufferAdr + CurrentIndex

    If(X_Axis = 1)
        X_Adr = CurrentBufferAdr + CurrentIndex + BufferLength
    End If
    If(Y_Axis = 1)
        Y_Adr = CurrentBufferAdr + CurrentIndex + 2*BufferLength
    End If
    If(Z_Axis = 1)
        Z_Adr = CurrentBufferAdr + CurrentIndex + 3*BufferLength
    End If
    If(U_Axis = 1)
        U_Adr = CurrentBufferAdr + CurrentIndex + 4*BufferLength
    End If
    If(V_Axis = 1)
        V_Adr = CurrentBufferAdr + CurrentIndex + 5*BufferLength
    End If
    If(W_Axis = 1)
        W_Adr = CurrentBufferAdr + CurrentIndex + 6*BufferLength
    End If
    If(A_Axis = 1)
        A_Adr = CurrentBufferAdr + CurrentIndex + 7*BufferLength
    End If
    If(B_Axis = 1)
        B_Adr = CurrentBufferAdr + CurrentIndex + 8*BufferLength
    End If
    If(C_Axis = 1)
        C_Adr = CurrentBufferAdr + CurrentIndex + 9*BufferLength
    End If
Return

; Subroutines 4-7 *********************************************************************************
; Calculate velocities for next move - 4: Master, 5: Prev->Current, 6: Prev->Next, 7: Current->Next
; Velocities are multiplied by 1000 because the units of Time is milliseconds and the units
; of velocity is user_units/second in the PVT move definition
; *************************************************************************************************


N4
    If(Time = 0)                        ; Set error and abort if demanded move time is zero
        Status = 3
        Error = 2
        CMD"A"
        Dwell 0
        Time = 1000
    End If

    ; Select velocity calculation based on VelMode value
    If(VelMode = 1)
        GoSub5                          ; Prev -> Current
    EndIf
    If(VelMode = 0 or VelMode > 2)
        GoSub6                          ; Prev -> Next
    EndIf
    If(VelMode = 2)
        GoSub7                          ; Current -> Next
    EndIf
Return

N5
    X_Vel = 1000*(X_Coord - Prev_X)/Time
    Y_Vel = 1000*(Y_Coord - Prev_Y)/Time
    Z_Vel = 1000*(Z_Coord - Prev_Z)/Time
    U_Vel = 1000*(U_Coord - Prev_U)/Time
    V_Vel = 1000*(V_Coord - Prev_V)/Time
    W_Vel = 1000*(W_Coord - Prev_W)/Time
    A_Vel = 1000*(A_Coord - Prev_A)/Time
    B_Vel = 1000*(B_Coord - Prev_B)/Time
    C_Vel = 1000*(C_Coord - Prev_C)/Time
Return

N6
    X_Vel = 1000*(Next_X - Prev_X)/(Time + Next_Time)
    Y_Vel = 1000*(Next_Y - Prev_Y)/(Time + Next_Time)
    Z_Vel = 1000*(Next_Z - Prev_Z)/(Time + Next_Time)
    U_Vel = 1000*(Next_U - Prev_U)/(Time + Next_Time)
    V_Vel = 1000*(Next_V - Prev_V)/(Time + Next_Time)
    W_Vel = 1000*(Next_W - Prev_W)/(Time + Next_Time)
    A_Vel = 1000*(Next_A - Prev_A)/(Time + Next_Time)
    B_Vel = 1000*(Next_B - Prev_B)/(Time + Next_Time)
    C_Vel = 1000*(Next_C - Prev_C)/(Time + Next_Time)
Return

N7
    X_Vel = 1000*(Next_X - X_Coord)/Next_Time
    Y_Vel = 1000*(Next_Y - Y_Coord)/Next_Time
    Z_Vel = 1000*(Next_Z - Z_Coord)/Next_Time
    U_Vel = 1000*(Next_U - U_Coord)/Next_Time
    V_Vel = 1000*(Next_V - V_Coord)/Next_Time
    W_Vel = 1000*(Next_W - W_Coord)/Next_Time
    A_Vel = 1000*(Next_A - A_Coord)/Next_Time
    B_Vel = 1000*(Next_B - B_Coord)/Next_Time
    C_Vel = 1000*(Next_C - C_Coord)/Next_Time
Return

; Subroutine 8 ************************************************************************************
; Move axes
; Set to Q Variables before move call to shorten command - The PMAC can't process it otherwise
; *************************************************************************************************

N8
    Q1 = X_Coord
    Q2 = X_Vel
    Q3 = Y_Coord
    Q4 = Y_Vel
    Q5 = Z_Coord
    Q6 = Z_Vel
    Q7 = U_Coord
    Q8 = U_Vel
    Q9 = V_Coord
    Q10 = V_Vel
    Q11 = W_Coord
    Q12 = W_Vel
    Q13 = A_Coord
    Q14 = A_Vel
    Q15 = B_Coord
    Q16 = B_Vel
    Q17 = C_Coord
    Q18 = C_Vel

    X(Q1):(Q2) Y(Q3):(Q4) Z(Q5):(Q6) U(Q7):(Q8) V(Q9):(Q10) W(Q11):(Q12) A(Q13):(Q14) B(Q15):(Q16) ;C(Q17):(Q18)
Return

; User Subroutines ********************************************************************************
; Subroutines to be used via the user buffer - 10: Set Trigger High, 11: Set Trigger Low
; *************************************************************************************************

N10
    Trigger = 1
Return

N11
    Trigger = 0
Return

Close
