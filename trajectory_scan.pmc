; *****************************************************************************************
; Variables
; *****************************************************************************************

#DEFINE RT_ADR P1

; EPICS required variables
#DEFINE CURRENT_BUFFER  P(RT_ADR + 1)   ; A or B buffer address
#DEFINE BUFFER_LENGTH   P(RT_ADR + 2)   ; Length of a single buffer e.g. AX, BX, ..., User
#DEFINE BUFFER_FILL     P(RT_ADR + 3)   ; The index that current buffers have been filled up to
#DEFINE CURRENT_INDEX   P(RT_ADR + 4)   ; Current index position in buffers
#DEFINE STATUS          P(RT_ADR + 5)   ; Status of motion program for EPICS
#DEFINE TOTAL_POINTS    P(RT_ADR + 6)   ; Total number of points scanned through
#DEFINE CANCEL          P(RT_ADR + 7)   ; Cancel trigger for EPICS
#DEFINE AXES            P(RT_ADR + 8)   ; An int specifying which axes to use (X,Y,Z,U...)
                                        ; between 1 and 256

; Motion program specific variables
#DEFINE BUFFER_START_A  P(RT_ADR + 9)   ; Start index of first sub-buffer of buffer A (AX)
#DEFINE BUFFER_START_B  P(RT_ADR + 10)  ; Start index of first sub-buffer of buffer B (BX)
#DEFINE X_COORD         P(RT_ADR + 11)  ; Pointer to current buffer X index
#DEFINE Y_COORD         P(RT_ADR + 12)  ; Pointer to current buffer Y index
#DEFINE Z_COORD         P(RT_ADR + 13)  ; Pointer to current buffer Z index
#DEFINE U_COORD         P(RT_ADR + 14)  ; Pointer to current buffer U index
#DEFINE V_COORD         P(RT_ADR + 15)  ; Pointer to current buffer V index
#DEFINE W_COORD         P(RT_ADR + 16)  ; Pointer to current buffer W index
#DEFINE A_COORD         P(RT_ADR + 17)  ; Pointer to current buffer A index
#DEFINE B_COORD         P(RT_ADR + 18)  ; Pointer to current buffer B index
#DEFINE C_COORD         P(RT_ADR + 19)  ; Pointer to current buffer C index
#DEFINE TIME            P(RT_ADR + 20)  ; Pointer to current buffer Time value
#DEFINE USER            P(RT_ADR + 21)  ; Pointer to current buffer User value
#DEFINE X_AXIS          P(RT_ADR + 22)  ; Specifiers for for what axes are to be used
#DEFINE Y_AXIS          P(RT_ADR + 23)
#DEFINE Z_AXIS          P(RT_ADR + 24)
#DEFINE U_AXIS          P(RT_ADR + 25)
#DEFINE V_AXIS          P(RT_ADR + 26)
#DEFINE W_AXIS          P(RT_ADR + 27)
#DEFINE A_AXIS          P(RT_ADR + 28)
#DEFINE B_AXIS          P(RT_ADR + 29)
#DEFINE C_AXIS          P(RT_ADR + 30)
#DEFINE NUM_AXES        P(RT_ADR + 31)  ; Number of axes being used - IF SPLITTING BUFFERS DYNAMICALLY?
#DEFINE MOTOR_INDEX     P(RT_ADR + 32)  ; Current motor to assign


; *****************************************************************************************
; Set-Up
; *****************************************************************************************

DEL GAT
; Coordinate System 1
&1
; Make sure all buffers are closed
CLOSE

; Check which axes are required
GOSUB1
; Assign required axes to motors
GOSUB2                                  ; >>> Update to assign axes to different CSs

; *****************************************************************************************
; Program
; *****************************************************************************************

OPEN PROG 1
CLEAR

SPLINE1 TM10
ABS

; Set Initial Values
BUFFER_LENGTH = XXXX
BUFFER_START_A = $XXXX
BUFFER_START_B = BUFFER_START_A + 11*BUFFER_LENGTH

CURRENT_BUFFER = BUFFER_START_A
CURRENT_INDEX = CURRENT_BUFFER
STATUS = 0
TOTAL_POINTS = 0
CANCEL = 0
BUFFER_FILL = BUFFER_LENGTH

; <<< Allow EPICS to assign any values here, so they won't be reset - Or just don't set variables that EPICS will set?

WHILE(CANCEL != 1) ; Run indefinitely, but allow EPICS to stop program


    ; <<< EPICS to set BUFFER_FILL here

    CURRENT_INDEX = CURRENT_BUFFER
    WHILE(CURRENT_INDEX < BUFFER_FILL)

        X_COORD = CURRENT_INDEX                         ; FIX FOR WHEN SOME AXES NOT USED?
        Y_COORD = Q($(CURRENT_INDEX+BUFFER_LENGTH))
        Z_COORD = Q($(CURRENT_INDEX+2*BUFFER_LENGTH))
        U_COORD = Q($(CURRENT_INDEX+3*BUFFER_LENGTH))
        V_COORD = Q($(CURRENT_INDEX+4*BUFFER_LENGTH))
        W_COORD = Q($(CURRENT_INDEX+5*BUFFER_LENGTH))
        A_COORD = Q($(CURRENT_INDEX+6*BUFFER_LENGTH))
        B_COORD = Q($(CURRENT_INDEX+7*BUFFER_LENGTH))
        C_COORD = Q($(CURRENT_INDEX+8*BUFFER_LENGTH))
        TIME = Q($(CURRENT_INDEX+9*BUFFER_LENGTH))
        USER = Q($(CURRENT_INDEX+10*BUFFER_LENGTH))

        X(X_COORD) Y(Y_COORD) Z(Z_COORD) U(U_COORD) V(V_COORD) W(W_COORD) A(A_COORD) B(B_COORD) C(C_COORD)

        IF(USER > 0)
            GOSUB(USER)
        ENDIF

        CURRENT_INDEX = CURRENT_INDEX + 1
        TOTAL_POINTS = TOTAL_POINTS + 1

    END WHILE

    IF CURRENT_BUFFER = BUFFER_START_A
        CURRENT_BUFFER = BUFFER_START_B
    ELSE
        CURRENT_BUFFER = BUFFER_START_A

ENDWHILE

CLOSE

; Buffers: AX, AY, AZ, AU, AV, AW, AA, AB, AC, ATime, AUser
;          BX, BY, BZ, BU, BV, BW, BA, BB, BC, BTime, BUser

; To-Do:
;   * Do we need to change the program based on which axes are being used, or can we just call
;       empty move calls on them? MOVE CALLS ON UNASSIGNED AXES SEEMS TO WORK OK
;   * Can we distribute buffers like PMAC does for axes, so the maximum number for each is allowed?
        Do we need to do this, or can we just have 1/11 each always?
;   * Can we specify delta times by changing TM before each move, is this resource heavy or
;       or are there any other issues with this? If not, how do we use SPLINE2 to specify
;       delta times? - X1000 TA50 is supposed to do it?


; SUB1 ************************************************************************************
; Convert <AXES> to binary values for each axis to decide which axes to use
; *****************************************************************************************

N1

X_AXIS = 0
Y_AXIS = 0
Z_AXIS = 0
U_AXIS = 0
V_AXIS = 0
W_AXIS = 0
A_AXIS = 0
B_AXIS = 0
C_AXIS = 0

IF(AXES == 256)
    C_AXIS = 1
IF(AXES > 128)
    B_AXIS = 1
    AXES = AXES - 128
IF(AXES > 64)
    A_AXIS = 1
    AXES = AXES - 64
IF(AXES > 32)
    W_AXIS = 1
    AXES = AXES - 32
IF(AXES > 16)
    V_AXIS = 1
    AXES = AXES - 16
IF(AXES > 8)
    U_AXIS = 1
    AXES = AXES - 8
IF(AXES > 4)
    Z_AXIS = 1
    AXES = AXIS - 4
IF(AXES > 2)
    Y_AXIS = 1
    AXES = AXES - 2
IF(AXES > 0)
    X_AXIS = 1

RETURN

; SUB2 ************************************************************************************
; Use <*_AXIS> values to assign required axes to motors
; *****************************************************************************************

N2

MOTOR_INDEX = 1
IF(X_AXIS == 1)
    #(MOTOR_INDEX)->X
    MOTOR_INDEX = MOTOR_INDEX + 1
IF(Y_AXIS == 1)
    #(MOTOR_INDEX)->Y
    MOTOR_INDEX = MOTOR_INDEX + 1
IF(Z_AXIS == 1)
    #(MOTOR_INDEX)->Z
    MOTOR_INDEX = MOTOR_INDEX + 1
IF(U_AXIS == 1)
    #(MOTOR_INDEX)->U
    MOTOR_INDEX = MOTOR_INDEX + 1
IF(V_AXIS == 1)
    #(MOTOR_INDEX)->V
    MOTOR_INDEX = MOTOR_INDEX + 1
IF(W_AXIS == 1)
    #(MOTOR_INDEX)->W
    MOTOR_INDEX = MOTOR_INDEX + 1
IF(A_AXIS == 1)
    #(MOTOR_INDEX)->A
    MOTOR_INDEX = MOTOR_INDEX + 1
IF(B_AXIS == 1)
    #(MOTOR_INDEX)->B
    MOTOR_INDEX = MOTOR_INDEX + 1
IF(C_AXIS == 1)
    #(MOTOR_INDEX)->C

RETURN
; *****************************************************************************************
