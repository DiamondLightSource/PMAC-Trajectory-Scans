; *****************************************************************************************
; Variables
; *****************************************************************************************

#Define RootVar 4000

; EPICS required variables
#Define CurrentBufferAdr  M(RootVar + 1)   	; A or B buffer address
#Define BufferLength   		M(RootVar + 2)   	; Length of a single buffer e.g. AX, BX, ..., User
#Define BufferFill     		M(RootVar + 3)   	; The index that current buffers have been filled up to
#Define CurrentIndex   		M(RootVar + 4)   	; Current index position in buffers
#Define Status          	M(RootVar + 5)   	; Status of motion program for EPICS
#Define TotalPoints    		M(RootVar + 6)   	; Total number of points scanned through
#Define Cancel          	M(RootVar + 7)   	; Cancel trigger for EPICS
#Define Axes            	M(RootVar + 8)   	; An int specifying which axes to use (X,Y,Z,U...)
                                         		; between 1 and 256
#Define BufferAdr_A 			M(RootVar + 9)   	; Start index of first sub-buffer of buffer A (AX)
#Define BufferAdr_B 			M(RootVar + 10)  	; Start index of first sub-buffer of buffer B (BX)

; Motion program specific variables
#Define Next_X	         	M(RootVar + 11)  	; Pointer to next buffer X index
#Define Next_Y         		M(RootVar + 12)  	; Pointer to next buffer Y index
#Define Next_Z        		M(RootVar + 13)  	; Pointer to next buffer Z index
#Define Next_U         		M(RootVar + 14)  	; Pointer to next buffer U index
#Define Next_V        		M(RootVar + 15)  	; Pointer to next buffer V index
#Define Next_W        		M(RootVar + 16)  	; Pointer to next buffer W index
#Define Next_A        		M(RootVar + 17)  	; Pointer to next buffer A index
#Define Next_B        		M(RootVar + 18)  	; Pointer to next buffer B index
#Define Next_C        		M(RootVar + 19)  	; Pointer to next buffer C index
#Define Time            	M(RootVar + 20)  	; Pointer to next buffer Time value
#Define User            	M(RootVar + 21)  	; Pointer to next buffer User value

#Define X_Axis          	M(RootVar + 22)  	; Specifiers for what axes are to be used
#Define Y_Axis          	M(RootVar + 23)
#Define Z_Axis          	M(RootVar + 24)
#Define U_Axis          	M(RootVar + 25)
#Define V_Axis          	M(RootVar + 26)
#Define W_Axis          	M(RootVar + 27)
#Define A_Axis          	M(RootVar + 28)
#Define B_Axis          	M(RootVar + 29)
#Define C_Axis          	M(RootVar + 30)

#Define NumAxes        		M(RootVar + 31)  	; Number of axes being used - IF SPLITTING BUFFERS DYNAMICALLY?
#Define MotorIndex   			M(RootVar + 32)  	; Current motor to assign - IF SETTING MOTORS DYNAMICALLY
#Define MoveTime					M(RootVar + 33)  	; Time of moves

#Define X_Adr         		M4034  	; Pointer to current buffer X index
X_Adr->X:$4FAB,0,24								; Pointer to M4011 - Next_X
#Define Y_Adr         		M4035  	; Pointer to current buffer Y index
Y_Adr->X:$4FAC,0,24								; Pointer to M4012 - Next_Y
#Define Z_Adr        			M4036  	; Pointer to current buffer Z index
Z_Adr->X:$4FAD,0,24								; Pointer to M4013 - Next_Z
#Define U_Adr         		M4037  	; Pointer to current buffer U index
U_Adr->X:$4FAE,0,24								; Pointer to M4014 - Next_U
#Define V_Adr      				M4038  	; Pointer to current buffer V index
V_Adr->X:$4FAF,0,24								; Pointer to M4015 - Next_V
#Define W_Adr        			M4039  	; Pointer to current buffer W index
W_Adr->X:$4FB0,0,24								; Pointer to M4016 - Next_W
#Define A_Adr        			M4040  	; Pointer to current buffer A index
A_Adr->X:$4FB1,0,24								; Pointer to M4017 - Next_A
#Define B_Adr        			M4041  	; Pointer to current buffer B index
B_Adr->X:$4FB2,0,24								; Pointer to M4018 - Next_B
#Define C_Adr        			M4042  	; Pointer to current buffer C index
C_Adr->X:$4FB3,0,24								; Pointer to M4019 - Next_C

#Define Prev_X 						M(RootVar + 43)
#Define X_Coord						M(RootVar + 44)
#Define Prev_Y 						M(RootVar + 45)
#Define Y_Coord						M(RootVar + 46)
#Define Prev_Z 						M(RootVar + 47)
#Define Z_Coord						M(RootVar + 48)
#Define Prev_U 						M(RootVar + 49)
#Define U_Coord						M(RootVar + 50)
#Define Prev_V 						M(RootVar + 51)
#Define V_Coord						M(RootVar + 52)
#Define Prev_W 						M(RootVar + 53)
#Define W_Coord						M(RootVar + 54)
#Define Prev_A 						M(RootVar + 55)
#Define A_Coord						M(RootVar + 56)
#Define Prev_B 						M(RootVar + 57)
#Define B_Coord						M(RootVar + 58)
#Define Prev_C 						M(RootVar + 59)
#Define C_Coord						M(RootVar + 60)

#Define X_Vel							M(RootVar + 61)
#Define Y_Vel							M(RootVar + 62)
#Define Z_Vel							M(RootVar + 63)
#Define U_Vel							M(RootVar + 64)
#Define V_Vel							M(RootVar + 65)
#Define W_Vel							M(RootVar + 66)
#Define A_Vel							M(RootVar + 67)
#Define B_Vel							M(RootVar + 68)
#Define C_Vel							M(RootVar + 69)

; *****************************************************************************************
; Set-Up
; *****************************************************************************************

Del Gat
; Coordinate System 1
&1
; Make sure all buffers are closed
Close

#1->X
#2->Y
#3->Z
#4->U
#5->V
#6->W
#7->A
#8->B
#9->C

; Set Initial Values
BufferLength = 1000
BufferAdr_A = $30000
BufferAdr_B = BufferAdr_A + 11*BufferLength

; *****************************************************************************************
; Program
; *****************************************************************************************

Open Prog 1
Clear

; Check which axes are required
GoSub1
; Assign required axes to motors
;GoSub2                                  ; >>> Update to assign axes to different CSs?

MoveTime = 500
PVT (MoveTime)
Abs
FRAX(X,Y,Z,U,V,W,A,B,C)


CurrentBufferAdr = BufferAdr_A
CurrentIndex = 0
Status = 0
TotalPoints = 0
Cancel = 0
BufferFill = BufferLength

Prev_X = 0 X_Coord = 0
Prev_Y = 0 Y_Coord = 0
Prev_Z = 0 Z_Coord = 0
Prev_U = 0 U_Coord = 0
Prev_V = 0 V_Coord = 0
Prev_W = 0 W_Coord = 0
Prev_A = 0 A_Coord = 0
Prev_B = 0 B_Coord = 0
Prev_C = 0 C_Coord = 0

; <<< Allow EPICS to assign any values here, so they won't be reset - Or just don't set variables that EPICS will set?

While(Cancel != 1 and BufferFill > 0) ; Run indefinitely, but allow EPICS to stop program

    ; <<< EPICS to set BUFFER_FILL here

    CurrentIndex = 0
    While(CurrentIndex < BufferFill)

		    GoSub2	; Shift values through Next_* -> *_Coord -> Prev_*
		    
		    ; Increment Addresses
		    GoSub4
		    
				; Calculate velocities
		    GoSub3

				; Set to Q Variables before move call to shorten command
				Q1 = X_Coord
				Q2 = X_Vel
				Q3 = Y_Coord
				Q4 = Y_Vel
				Q5 = Z_Coord
				Q6 = Z_Vel
				Q7 = U_Coord
				Q8 = U_Vel
				Q9 = V_Coord
				Q10 = V_Vel
				Q11 = W_Coord
				Q12 = W_Vel
				Q13 = A_Coord
				Q14 = A_Vel
				Q15 = B_Coord
				Q16 = B_Vel
				Q17 = C_Coord
				Q18 = C_Vel

        X(Q1):(Q2) Y(Q3):(Q4) Z(Q5):(Q6) U(Q7):(Q8) V(Q9):(Q10) W(Q11):(Q12) A(Q13):(Q14) B(Q15):(Q16) C(Q17):(Q18)

        ; Run any required subroutine >>> Do we need to be able to run more than one?
        If(User > 0)
            GoSub(User)
        End If

        CurrentIndex = CurrentIndex + 1
        TotalPoints = TotalPoints + 1

    End While

    ; Might need second move call because of double endif statements - won't merge otherwise

    If(CurrentBufferAdr = BufferAdr_A)
        CurrentBufferAdr = BufferAdr_B
    Else
        CurrentBufferAdr = BufferAdr_A
    End If

End While

Status == 1

; Buffers: AX, AY, AZ, AU, AV, AW, AA, AB, AC, ATime, AUser
;          BX, BY, BZ, BU, BV, BW, BA, BB, BC, BTime, BUser


; Subroutine 1 ************************************************************************************
; Convert <Axes> to binary values for each axis to decide which axes to use
; *************************************************************************************************

N1
		X_Axis = 0
		Y_Axis = 0
		Z_Axis = 0
		U_Axis = 0
		V_Axis = 0
		W_Axis = 0
		A_Axis = 0
		B_Axis = 0
		C_Axis = 0
		
		If(Axes > 256)
		    X_Axis = 1
		    Axes = Axes - 256
		End If
		If(Axes > 128)
		    Y_Axis = 1
		    Axes = Axes - 128
		End If
		If(Axes > 64)
		    Z_Axis = 1
		    Axes = Axes - 64
		End If
		If(Axes > 32)
		    U_Axis = 1
		    Axes = Axes - 32
		End If
		If(Axes > 16)
		    V_Axis = 1
		    Axes = Axes - 16
		End If
		If(Axes > 8)
		    W_Axis = 1
		    Axes = Axes - 8
		End If
		If(Axes > 4)
		    A_Axis = 1
		    Axes = Axes - 4
		End If
		If(Axes > 2)
		    B_Axis = 1
		    Axes = Axes - 2
		End If
		If(Axes > 0)
		    C_Axis = 1
		End If
Return

; Subroutine 2 ************************************************************************************
; Shift coordinate buffer through Next -> Coord -> Prev
; *************************************************************************************************

N2
		Prev_X = X_Coord
		X_Coord = Next_X
		Prev_Y = Y_Coord
		Y_Coord = Next_Y
		Prev_Z = Z_Coord
		Z_Coord = Next_Z
		Prev_U = U_Coord
		U_Coord = Next_U
		Prev_V = V_Coord
		V_Coord = Next_V
		Prev_W = W_Coord
		W_Coord = Next_W
		Prev_A = A_Coord
		A_Coord = Next_A
		Prev_B = B_Coord
		B_Coord = Next_B
		Prev_C = C_Coord
		C_Coord = Next_C
Return

; Subroutine 3 ************************************************************************************
; Calculate velocities for next move
; *************************************************************************************************

N3
		X_Vel = (Next_X - Prev_X)/(2*MoveTime)
		Y_Vel = (Next_Y - Prev_Y)/(2*MoveTime)
		Z_Vel = (Next_Z - Prev_Z)/(2*MoveTime)
		U_Vel = (Next_U - Prev_U)/(2*MoveTime)
		V_Vel = (Next_V - Prev_V)/(2*MoveTime)
		W_Vel = (Next_W - Prev_W)/(2*MoveTime)
		A_Vel = (Next_A - Prev_A)/(2*MoveTime)
		B_Vel = (Next_B - Prev_B)/(2*MoveTime)
		C_Vel = (Next_C - Prev_C)/(2*MoveTime)
		
		; >>> Need previous times to calculate velocities
Return


N4
		If(X_Axis = 1) 
    		X_Adr = CurrentBufferAdr + CurrentIndex 
    End If
    If(Y_Axis = 1)
    		Y_Adr = CurrentBufferAdr + CurrentIndex + BufferLength
    End If
    If(Z_Axis = 1)
    		Z_Adr = CurrentBufferAdr + CurrentIndex + 2*BufferLength
    End If
    If(U_Axis = 1)
    		U_Adr = CurrentBufferAdr + CurrentIndex + 3*BufferLength
    End If
    If(V_Axis = 1)
    		V_Adr = CurrentBufferAdr + CurrentIndex + 4*BufferLength
    End If
    If(W_Axis = 1)
    		W_Adr = CurrentBufferAdr + CurrentIndex + 5*BufferLength
    End If
    If(A_Axis = 1)
    		A_Adr = CurrentBufferAdr + CurrentIndex + 6*BufferLength
    End If
    If(B_Axis = 1)
    		B_Adr = CurrentBufferAdr + CurrentIndex + 7*BufferLength
    End If
    If(C_Axis = 1)
    		C_Adr = CurrentBufferAdr + CurrentIndex + 8*BufferLength
    End If
    
		Time = 	CurrentBufferAdr + CurrentIndex + 9*BufferLength
		User = 	CurrentBufferAdr + CurrentIndex + 10*BufferLength

Close