; *****************************************************************************************
; Variables
; *****************************************************************************************

#Define RootVar 4000

; EPICS Required Variables - (P4000 address = $6FA0)

#Define Status          	P(RootVar + 1)   		; Status of motion program for EPICS - 0: Idle, 1: Running, 2: Finished, 3: Error
#Define Abort          		P(RootVar + 2)   		; Abort trigger for EPICS
#Define Axes            	P(RootVar + 3)   		; An int between 1 and 511 specifying which axes to use
#Define BufferLength   		P(RootVar + 4)   		; Length of a single buffer e.g. AX, AY...
#Define TotalPoints    		P(RootVar + 5)   		; Total number of points scanned through

#Define CurrentIndex   		P(RootVar + 6)   		; Current index position in buffer
#Define CurrentBuffer			P(RootVar + 7)			; Current buffer specifier - 0: A, 1: B

#Define BufferAdr_A 			P(RootVar + 8)			; Start index of buffer A
#Define BufferAdr_B 			P(RootVar + 9)			; Start index of buffer B
#Define CurrentBufferAdr  P(RootVar + 10)   	; A or B buffer address

#Define BufferFill_A			P(RootVar + 11)			; Fill level of buffer A
#Define BufferFill_B			P(RootVar + 12)			; Fill level of buffer B
#Define CurrentBufferFill P(RootVar + 13)   	; A or B buffer fill level

; Motion Program Variables

#Define X_Axis          	P(RootVar + 101)  	; Specifiers for what axes are to be used
#Define Y_Axis          	P(RootVar + 102)
#Define Z_Axis          	P(RootVar + 103)
#Define U_Axis          	P(RootVar + 104)
#Define V_Axis          	P(RootVar + 105)
#Define W_Axis          	P(RootVar + 106)
#Define A_Axis          	P(RootVar + 107)
#Define B_Axis          	P(RootVar + 108)
#Define C_Axis          	P(RootVar + 109)

#Define Time							P(RootVar + 110)		; Current coordinate values
#Define X_Coord						P(RootVar + 111)
#Define Y_Coord						P(RootVar + 112)
#Define Z_Coord						P(RootVar + 113)
#Define U_Coord						P(RootVar + 114)
#Define V_Coord						P(RootVar + 115)
#Define W_Coord						P(RootVar + 116)
#Define A_Coord						P(RootVar + 117)
#Define B_Coord						P(RootVar + 118)
#Define C_Coord						P(RootVar + 119)
#Define User							P(RootVar + 120)
#Define VelMode						P(RootVar + 121)
#Define Next_Time					P(RootVar + 122)

#Define Prev_X 						P(RootVar + 131)		; Previous coordinate values
#Define Prev_Y 						P(RootVar + 132)
#Define Prev_Z 						P(RootVar + 133)
#Define Prev_U 						P(RootVar + 134)
#Define Prev_V 						P(RootVar + 135)
#Define Prev_W 						P(RootVar + 136)
#Define Prev_A 						P(RootVar + 137)
#Define Prev_B 						P(RootVar + 138)
#Define Prev_C 						P(RootVar + 139)

#Define X_Vel							P(RootVar + 141)		; Move velocities
#Define Y_Vel							P(RootVar + 142)
#Define Z_Vel							P(RootVar + 143)
#Define U_Vel							P(RootVar + 144)
#Define V_Vel							P(RootVar + 145)
#Define W_Vel							P(RootVar + 146)
#Define A_Vel							P(RootVar + 147)
#Define B_Vel							P(RootVar + 148)
#Define C_Vel							P(RootVar + 149)

; Address-Based Variables

#Define BlankAddress			M4015								; Address storing a zero for unused axes to point to
BlankAddress->D:$3FFFF,0,48

#Define Next_Time_N      	M4000  							; Next coordinate values
#Define Next_X	         	M4001
#Define Next_Y         		M4002
#Define Next_Z        		M4003
#Define Next_U         		M4004
#Define Next_V        		M4005
#Define Next_W        		M4006
#Define Next_A        		M4007
#Define Next_B        		M4008
#Define Next_C        		M4009
#Define Next_User     		M4010
#Define NextVelMode				M4011

NextVelMode->X:$3FFFF,4,4											; Set initial pointers and type
Next_User->X:$3FFFF,0,4
Next_Time_N->Y:$3FFFF,0,24
Next_X->D:$3FFFF,0,48
Next_Y->D:$3FFFF,0,48
Next_Z->D:$3FFFF,0,48
Next_U->D:$3FFFF,0,48
Next_V->D:$3FFFF,0,48
Next_W->D:$3FFFF,0,48
Next_A->D:$3FFFF,0,48
Next_B->D:$3FFFF,0,48
Next_C->D:$3FFFF,0,48

#Define Time_Adr        	M4020  							; Pointers to Next_* coordinate addresses
#Define X_Adr         		M4021
#Define Y_Adr         		M4022
#Define Z_Adr        			M4023
#Define U_Adr         		M4024
#Define V_Adr      				M4025
#Define W_Adr        			M4026
#Define A_Adr        			M4027
#Define B_Adr        			M4028
#Define C_Adr        			M4029
#Define User_Adr        	M4030

Time_Adr->Y$4FA0,0,24													; Assignments for pointers to M address locations
X_Adr->Y:$4FA1,0,24														; M0 = $4000 -> M4000 = $4FA0
Y_Adr->Y:$4FA2,0,24
Z_Adr->Y:$4FA3,0,24
U_Adr->Y:$4FA4,0,24
V_Adr->Y:$4FA5,0,24
W_Adr->Y:$4FA6,0,24
A_Adr->Y:$4FA7,0,24
B_Adr->Y:$4FA8,0,24
C_Adr->Y:$4FA9,0,24
User_Adr->Y:$4FAA,0,24

#Define RTE								M4031
RTE->Y:$203F,22

; *****************************************************************************************
; Set-Up
; *****************************************************************************************

Del Gat

; Set Initial Values
BufferLength = 50
BufferAdr_A = $30000
BufferAdr_B = BufferAdr_A + 11*BufferLength
BlankAddress = 0
Status = 0

; Make sure all buffers are closed
Close

; *****************************************************************************************
; Program
; *****************************************************************************************

Open Prog 1
Clear

; Check which axes are required
GoSub1

Abs
FRAX(X,Y,Z,U,V,W,A,B,C)

CurrentBufferAdr = BufferAdr_A
CurrentIndex = 0
TotalPoints = 0
Abort = 0
CurrentBufferFill = BufferFill_A
CurrentBuffer = 0

Prev_X = 0 X_Coord = 0
Prev_Y = 0 Y_Coord = 0
Prev_Z = 0 Z_Coord = 0
Prev_U = 0 U_Coord = 0
Prev_V = 0 V_Coord = 0
Prev_W = 0 W_Coord = 0
Prev_A = 0 A_Coord = 0
Prev_B = 0 B_Coord = 0
Prev_C = 0 C_Coord = 0

GoSub6

P4201 = 0
P4202 = 0
Dwell 1000

; <<< Allow EPICS to assign any values here, so they won't be reset - Or just don't set variables that EPICS will set?

CMD"End Gat"	; Stop gathering
CMD"Del Gat"	; Deletes the gather buffer
CMD"Def Gat"	; Allocates all the available memory as gather buffer
Dwell 0		; Force CMD lines to execute
CMD"Gat"	; Starts gathering of the data

Status = 1
While(Abort != 1 and CurrentBufferFill > 0) ; Run indefinitely, but allow EPICS to stop program

		P4201 = P4201 + 1
    ; <<< EPICS to set BUFFER_FILL here
		
    CurrentIndex = 0
    While(Abort != 1 and CurrentIndex < CurrentBufferFill)
				
				P4202 = P4202 + 1
				
				Next_Time = Next_Time_N/4			; Convert 1/4s of a ms into ms
		    GoSub2	; Shift values through Next_* -> *_Coord -> Prev_*
    		
		    ; Increment addresses
		    GoSub6
		    
		    PVT (Time)
				; Calculate velocities
				GoSub8
    		
				; Move axes
				GoSub7
				
        ; Run any required subroutine >>> Do we need to be able to run more than one?
        If(User > 0)
            GoSub(User)
        End If
				
        CurrentIndex = CurrentIndex + 1
        TotalPoints = TotalPoints + 1
        
        If(M141 = 1 or M241 = 1 or RTE = 1)
        		Abort = 1
        		Status = 3
       	End If
        
    End While
    
    If(CurrentBufferFill != BufferLength)				; Abort if buffer wasn't completely full
    		Abort = 1
    End If
    
    ; >>> Might need second move call because of double endif statements - won't merge otherwise
		
    If(CurrentBuffer = 0)
        CurrentBufferAdr = BufferAdr_B
        CurrentBufferFill = BufferFill_B
        BufferFill_A = 0
        CurrentBuffer = 1
    Else
        CurrentBufferAdr = BufferAdr_A
        CurrentBufferFill = BufferFill_A
        BufferFill_B = 0
        CurrentBuffer = 0
    End If
    
End While

GoSub2					; Increment addresses to move to final Next_* point
GoSub8					; Calculate velocities
GoSub7					; Move axes

Status = 2

Dwell 0		; Force CMD lines to execute
CMD"End Gat"	; Send On-line command to stop data gathering
Dwell 0		; Force CMD lines to execute

; Buffers: AX, AY, AZ, AU, AV, AW, AA, AB, AC, ATime, AUser
;          BX, BY, BZ, BU, BV, BW, BA, BB, BC, BTime, BUser


; Subroutine 1 ************************************************************************************
; Convert <Axes> to binary values for each axis to decide which axes to use
; *************************************************************************************************

N1
		X_Axis = 0
		Y_Axis = 0
		Z_Axis = 0
		U_Axis = 0
		V_Axis = 0
		W_Axis = 0
		A_Axis = 0
		B_Axis = 0
		C_Axis = 0
		
		If(Axes > 255)
		    X_Axis = 1
		    Axes = Axes - 256
		End If
		If(Axes > 127)
		    Y_Axis = 1
		    Axes = Axes - 128
		End If
		If(Axes > 63)
		    Z_Axis = 1
		    Axes = Axes - 64
		End If
		If(Axes > 31)
		    U_Axis = 1
		    Axes = Axes - 32
		End If
		If(Axes > 15)
		    V_Axis = 1
		    Axes = Axes - 16
		End If
		If(Axes > 7)
		    W_Axis = 1
		    Axes = Axes - 8
		End If
		If(Axes > 3)
		    A_Axis = 1
		    Axes = Axes - 4
		End If
		If(Axes > 1)
		    B_Axis = 1
		    Axes = Axes - 2
		End If
		If(Axes > 0)
		    C_Axis = 1
		    Axes = Axes - 1
		End If
Return

; Subroutine 2 ************************************************************************************
; Shift coordinate buffer through Next -> Coord -> Prev
; *************************************************************************************************

N2
		Time = Next_Time
		Prev_X = X_Coord
		X_Coord = Next_X
		Prev_Y = Y_Coord
		Y_Coord = Next_Y
		Prev_Z = Z_Coord
		Z_Coord = Next_Z
		Prev_U = U_Coord
		U_Coord = Next_U
		Prev_V = V_Coord
		V_Coord = Next_V
		Prev_W = W_Coord
		W_Coord = Next_W
		Prev_A = A_Coord
		A_Coord = Next_A
		Prev_B = B_Coord
		B_Coord = Next_B
		Prev_C = C_Coord
		C_Coord = Next_C
		User = Next_User
		VelMode = NextVelMode
Return

; Subroutines 3-5 *********************************************************************************
; Calculate velocities for next move - 3: Prev->Current, 4: Prev->Next, 5: Current->Next
; *************************************************************************************************
; Multiply velocities by 1000 because units(Time): msec and units(velocity): sec in PVT move def

N3
		If(Time = 0)
				Status = 3
				CMD"A"
				Dwell 0
				Time = 1000
		End If
		X_Vel = 1000*(X_Coord - Prev_X)/Time
		Y_Vel = 1000*(Y_Coord - Prev_Y)/Time
		Z_Vel = 1000*(Z_Coord - Prev_Z)/Time
		U_Vel = 1000*(U_Coord - Prev_U)/Time
		V_Vel = 1000*(V_Coord - Prev_V)/Time
		W_Vel = 1000*(W_Coord - Prev_W)/Time
		A_Vel = 1000*(A_Coord - Prev_A)/Time
		B_Vel = 1000*(B_Coord - Prev_B)/Time
		C_Vel = 1000*(C_Coord - Prev_C)/Time
Return

N4
		If(Time = 0)
				Status = 3
				CMD"A"
				Dwell 0
				Time = 1000
		End If
		X_Vel = 1000*(Next_X - Prev_X)/(Time + Next_Time)
		Y_Vel = 1000*(Next_Y - Prev_Y)/(Time + Next_Time)
		Z_Vel = 1000*(Next_Z - Prev_Z)/(Time + Next_Time)
		U_Vel = 1000*(Next_U - Prev_U)/(Time + Next_Time)
		V_Vel = 1000*(Next_V - Prev_V)/(Time + Next_Time)
		W_Vel = 1000*(Next_W - Prev_W)/(Time + Next_Time)
		A_Vel = 1000*(Next_A - Prev_A)/(Time + Next_Time)
		B_Vel = 1000*(Next_B - Prev_B)/(Time + Next_Time)
		C_Vel = 1000*(Next_C - Prev_C)/(Time + Next_Time)
Return

N5
		If(Time = 0)
				Status = 3
				CMD"A"
				Dwell 0
				Time = 1000
		End If
		X_Vel = 1000*(Next_X - X_Coord)/Next_Time
		Y_Vel = 1000*(Next_Y - Y_Coord)/Next_Time
		Z_Vel = 1000*(Next_Z - Z_Coord)/Next_Time
		U_Vel = 1000*(Next_U - U_Coord)/Next_Time
		V_Vel = 1000*(Next_V - V_Coord)/Next_Time
		W_Vel = 1000*(Next_W - W_Coord)/Next_Time
		A_Vel = 1000*(Next_A - A_Coord)/Next_Time
		B_Vel = 1000*(Next_B - B_Coord)/Next_Time
		C_Vel = 1000*(Next_C - C_Coord)/Next_Time
Return

; Subroutine 6 ************************************************************************************
; Increment coordinate pointers (CurrentIndex is incremented in main)
; *************************************************************************************************

N6
		User_Adr = 	CurrentBufferAdr + CurrentIndex
		Time_Adr = 	CurrentBufferAdr + CurrentIndex
		If(X_Axis = 1) 
    		X_Adr = CurrentBufferAdr + CurrentIndex + BufferLength
    End If
    If(Y_Axis = 1)
    		Y_Adr = CurrentBufferAdr + CurrentIndex + 2*BufferLength
    End If
    If(Z_Axis = 1)
    		Z_Adr = CurrentBufferAdr + CurrentIndex + 3*BufferLength
    End If
    If(U_Axis = 1)
    		U_Adr = CurrentBufferAdr + CurrentIndex + 4*BufferLength
    End If
    If(V_Axis = 1)
    		V_Adr = CurrentBufferAdr + CurrentIndex + 5*BufferLength
    End If
    If(W_Axis = 1)
    		W_Adr = CurrentBufferAdr + CurrentIndex + 6*BufferLength
    End If
    If(A_Axis = 1)
    		A_Adr = CurrentBufferAdr + CurrentIndex + 7*BufferLength
    End If
    If(B_Axis = 1)
    		B_Adr = CurrentBufferAdr + CurrentIndex + 8*BufferLength
    End If
    If(C_Axis = 1)
    		C_Adr = CurrentBufferAdr + CurrentIndex + 9*BufferLength
    End If
Return

; Subroutine 7 ************************************************************************************
; Move axes
; *************************************************************************************************

N7
		; Set to Q Variables before move call to shorten command
		Q1 = X_Coord
		Q2 = X_Vel
		Q3 = Y_Coord
		Q4 = Y_Vel
		Q5 = Z_Coord
		Q6 = Z_Vel
		Q7 = U_Coord
		Q8 = U_Vel
		Q9 = V_Coord
		Q10 = V_Vel
		Q11 = W_Coord
		Q12 = W_Vel
		Q13 = A_Coord
		Q14 = A_Vel
		Q15 = B_Coord
		Q16 = B_Vel
		Q17 = C_Coord
		Q18 = C_Vel

    X(Q1):(Q2) Y(Q3):(Q4) Z(Q5):(Q6) U(Q7):(Q8) V(Q9):(Q10) W(Q11):(Q12) A(Q13):(Q14) B(Q15):(Q16) ;C(Q17):(Q18)
		
Return

N8
		If(VelMode = 2)
		    GoSub3	; Prev -> Current
		EndIf
		If(VelMode = 0 or VelMode > 2)
				GoSub4	; Prev -> Next
		EndIf
		If(VelMode = 1)
				GoSub5	; Current -> Next
		EndIf
Return

Close