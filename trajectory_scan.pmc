; *****************************************************************************************
; Variables
; *****************************************************************************************

#Define RootVar 4000

; EPICS required variables
#Define CurrentBufferAdr  M(RootVar + 1)   	; A or B buffer address
#Define BufferLength   		M(RootVar + 2)   	; Length of a single buffer e.g. AX, BX, ..., User
#Define BufferFill     		M(RootVar + 3)   	; The index that current buffers have been filled up to
#Define CurrentIndex   		M(RootVar + 4)   	; Current index position in buffers
#Define Status          	M(RootVar + 5)   	; Status of motion program for EPICS
#Define TotalPoints    		M(RootVar + 6)   	; Total number of points scanned through
#Define Cancel          	M(RootVar + 7)   	; Cancel trigger for EPICS
#Define Axes            	M(RootVar + 8)   	; An int specifying which axes to use (X,Y,Z,U...)
                                         		; between 1 and 256

; Motion program specific variables
#Define BufferAdr_A 			M(RootVar + 9)   	; Start index of first sub-buffer of buffer A (AX)
#Define BufferAdr_B 			M(RootVar + 10)  	; Start index of first sub-buffer of buffer B (BX)
#Define X_Coord         	M(RootVar + 11)  	; Pointer to current buffer X index
#Define Y_Coord         	M(RootVar + 12)  	; Pointer to current buffer Y index
#Define Z_Coord        		M(RootVar + 13)  	; Pointer to current buffer Z index
#Define U_Coord         	M(RootVar + 14)  	; Pointer to current buffer U index
#Define V_Coord        		M(RootVar + 15)  	; Pointer to current buffer V index
#Define W_Coord        		M(RootVar + 16)  	; Pointer to current buffer W index
#Define A_Coord        		M(RootVar + 17)  	; Pointer to current buffer A index
#Define B_Coord        		M(RootVar + 18)  	; Pointer to current buffer B index
#Define C_Coord        		M(RootVar + 19)  	; Pointer to current buffer C index
#Define Time            	M(RootVar + 20)  	; Pointer to current buffer Time value
#Define User            	M(RootVar + 21)  	; Pointer to current buffer User value
#Define X_Axis          	M(RootVar + 22)  	; Specifiers for for what axes are to be used
#Define Y_Axis          	M(RootVar + 23)
#Define Z_Axis          	M(RootVar + 24)
#Define U_Axis          	M(RootVar + 25)
#Define V_Axis          	M(RootVar + 26)
#Define W_Axis          	M(RootVar + 27)
#Define A_Axis          	M(RootVar + 28)
#Define B_Axis          	M(RootVar + 29)
#Define C_Axis          	M(RootVar + 30)

#Define NumAxes        		M(RootVar + 31)  	; Number of axes being used - IF SPLITTING BUFFERS DYNAMICALLY?
#Define MotorIndex   			M(RootVar + 32)  	; Current motor to assign
#Define MoveTime					M(RootVar + 33)  	; Time of moves

#Define X_Adr         		M4034  	; Pointer to current buffer X index
X_Adr->X:$10400,0,24												; Set to dummy to start with
#Define Y_Adr         		M4035  	; Pointer to current buffer Y index
Y_Adr->X:$10400,0,24										 		; Set to dummy to start with
#Define Z_Adr        			M4036  	; Pointer to current buffer Z index
Z_Adr->X:$10400,0,24										 		; Set to dummy to start with
#Define U_Adr         		M4037  	; Pointer to current buffer U index
U_Adr->X:$10400,0,24										 		; Set to dummy to start with
#Define V_Adr      				M4038  	; Pointer to current buffer V index
V_Adr->X:$10400,0,24										 		; Set to dummy to start with
#Define W_Adr        			M4039  	; Pointer to current buffer W index
W_Adr->X:$10400,0,24										 		; Set to dummy to start with
#Define A_Adr        			M4040  	; Pointer to current buffer A index
A_Adr->X:$10400,0,24										 		; Set to dummy to start with
#Define B_Adr        			M4041  	; Pointer to current buffer B index
B_Adr->X:$10400,0,24										 		; Set to dummy to start with
#Define C_Adr        			M4042  	; Pointer to current buffer C index
C_Adr->X:$10400,0,24										 		; Set to dummy to start with


; *****************************************************************************************
; Set-Up
; *****************************************************************************************

Del Gat
; Coordinate System 1
&1
; Make sure all buffers are closed
Close

; *****************************************************************************************
; Program
; *****************************************************************************************

Open Prog 1
Clear

; Check which axes are required
GoSub1
; Assign required axes to motors
;GoSub2                                  ; >>> Update to assign axes to different CSs?

MoveTime = 500
PVT (MoveTime)
Abs

; Set Initial Values
BufferLength = 1000
BufferAdr_B = BufferAdr_A + 11*BufferLength

CurrentBufferAdr = BufferAdr_A
CurrentIndex = 0
Status = 0
TotalPoints = 0
Cancel = 0
BufferFill = BufferLength

; <<< Allow EPICS to assign any values here, so they won't be reset - Or just don't set variables that EPICS will set?

While(Cancel != 1) ; Run indefinitely, but allow EPICS to stop program

    ; <<< EPICS to set BUFFER_FILL here

    CurrentIndex = 0
    While(CurrentIndex < BufferFill)

				X_Adr = CurrentBufferAdr + CurrentIndex
				Y_Adr = CurrentBufferAdr + CurrentIndex + BufferLength
				Z_Adr = CurrentBufferAdr + CurrentIndex + 2*BufferLength
				U_Adr = CurrentBufferAdr + CurrentIndex + 3*BufferLength
				V_Adr = CurrentBufferAdr + CurrentIndex + 4*BufferLength
				W_Adr = CurrentBufferAdr + CurrentIndex + 5*BufferLength
				A_Adr = CurrentBufferAdr + CurrentIndex + 6*BufferLength
				B_Adr = CurrentBufferAdr + CurrentIndex + 7*BufferLength
				C_Adr = CurrentBufferAdr + CurrentIndex + 8*BufferLength
				Time = 	CurrentBufferAdr + CurrentIndex + 9*BufferLength
				User = 	CurrentBufferAdr + CurrentIndex + 10*BufferLength

				FRAX(X,Y,Z,U,V,W,A,B,C)
        ;XMoveTime = 10
        ; For All...

        X(X_Coord) Y(Y_Coord) Z(Z_Coord) U(U_Coord) V(V_Coord) W(W_Coord) A(A_Coord) B(B_Coord) C(C_Coord)

        ; Run any required subroutine
        If(User > 0)
            GoSub(User)
        End If

        CurrentIndex = CurrentIndex + 1
        TotalPoints = TotalPoints + 1

    End While

    ; Might need second move call because of double endif statements - won't merge otherwise

    If(CurrentBufferAdr = BufferAdr_A)
        CurrentBufferAdr = BufferAdr_B
    Else
        CurrentBufferAdr = BufferAdr_A
    End If

End While

; Buffers: AX, AY, AZ, AU, AV, AW, AA, AB, AC, ATime, AUser
;          BX, BY, BZ, BU, BV, BW, BA, BB, BC, BTime, BUser

; To-Do:
;   * Do we need to change the program based on which axes are being used, or can we just call
;       empty move calls on them? MOVE CALLS ON UNASSIGNED AXES SEEMS TO WORK OK
;   * Can we distribute buffers like PMAC does for axes, so the maximum number for each is allowed?
;        Do we need to do this, or can we just have 1/11 each always?


; Subroutine 1 ************************************************************************************
; Convert <Axes> to binary values for each axis to decide which axes to use
; *************************************************************************************************

N1

	X_Axis = 0
	Y_Axis = 0
	Z_Axis = 0
	U_Axis = 0
	V_Axis = 0
	W_Axis = 0
	A_Axis = 0
	B_Axis = 0
	C_Axis = 0
	
	If(Axes > 256)
	    X_Axis = 1
	    Axes = Axes - 256
	End If
	If(Axes > 128)
	    Y_Axis = 1
	    Axes = Axes - 128
	End If
	If(Axes > 64)
	    Z_Axis = 1
	    Axes = Axes - 64
	End If
	If(Axes > 32)
	    U_Axis = 1
	    Axes = Axes - 32
	End If
	If(Axes > 16)
	    V_Axis = 1
	    Axes = Axes - 16
	End If
	If(Axes > 8)
	    W_Axis = 1
	    Axes = Axes - 8
	End If
	If(Axes > 4)
	    A_Axis = 1
	    Axes = Axes - 4
	End If
	If(Axes > 2)
	    B_Axis = 1
	    Axes = Axes - 2
	End If
	If(Axes > 0)
	    C_Axis = 1
	End If
	
Return

Close

; Subroutine 2 ************************************************************************************
; Use <*_Axis> values to assign required axes to motors
; *************************************************************************************************

;N2

	;MOTOR_INDEX = 1
	;IF(X_AXIS == 1)
	;    #(MOTOR_INDEX)->X
	;    MOTOR_INDEX = MOTOR_INDEX + 1
	;IF(Y_AXIS == 1)
	;    #(MOTOR_INDEX)->Y
	;    MOTOR_INDEX = MOTOR_INDEX + 1
	;IF(Z_AXIS == 1)
	;    #(MOTOR_INDEX)->Z
	;    MOTOR_INDEX = MOTOR_INDEX + 1
	;IF(U_AXIS == 1)
	;    #(MOTOR_INDEX)->U
	;    MOTOR_INDEX = MOTOR_INDEX + 1
	;IF(V_AXIS == 1)
	;    #(MOTOR_INDEX)->V
	;    MOTOR_INDEX = MOTOR_INDEX + 1
	;IF(W_AXIS == 1)
	;    #(MOTOR_INDEX)->W
	;    MOTOR_INDEX = MOTOR_INDEX + 1
	;IF(A_AXIS == 1)
	;    #(MOTOR_INDEX)->A
	;    MOTOR_INDEX = MOTOR_INDEX + 1
	;IF(B_AXIS == 1)
	;    #(MOTOR_INDEX)->B
	;    MOTOR_INDEX = MOTOR_INDEX + 1
	;IF(C_AXIS == 1)
	;    #(MOTOR_INDEX)->C

;RETURN
; *************************************************************************************************
